// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: auth.proto

/* eslint-disable */
import {BinaryReader, BinaryWriter} from "@bufbuild/protobuf/wire";
import type {CallContext, CallOptions} from "nice-grpc-common";

export const protobufPackage = "auth";

/** Token payload containing user information */
export interface TokenPayload {
    email: string;
    name: string;
    sub: string;
    aud: string;
    exp: number;
    iat: number;
    iss: string;
    jti: string;
}

/** Request message for GetPublicKey */
export interface GetPublicKeyRequest {
    /** Optional key ID to get a specific public key */
    keyId?: string | undefined;
}

/** Response message for GetPublicKey */
export interface GetPublicKeyResponse {
    publicKey: string;
    keyId: string;
}

function createBaseTokenPayload(): TokenPayload {
    return {email: "", name: "", sub: "", aud: "", exp: 0, iat: 0, iss: "", jti: ""};
}

export const TokenPayload: MessageFns<TokenPayload> = {
    encode(message: TokenPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.email !== "") {
            writer.uint32(10).string(message.email);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.sub !== "") {
            writer.uint32(26).string(message.sub);
        }
        if (message.aud !== "") {
            writer.uint32(34).string(message.aud);
        }
        if (message.exp !== 0) {
            writer.uint32(40).int64(message.exp);
        }
        if (message.iat !== 0) {
            writer.uint32(48).int64(message.iat);
        }
        if (message.iss !== "") {
            writer.uint32(58).string(message.iss);
        }
        if (message.jti !== "") {
            writer.uint32(66).string(message.jti);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TokenPayload {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenPayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.email = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.sub = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }

                    message.aud = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }

                    message.exp = longToNumber(reader.int64());
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }

                    message.iat = longToNumber(reader.int64());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }

                    message.iss = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }

                    message.jti = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): TokenPayload {
        return {
            email: isSet(object.email) ? globalThis.String(object.email) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            sub: isSet(object.sub) ? globalThis.String(object.sub) : "",
            aud: isSet(object.aud) ? globalThis.String(object.aud) : "",
            exp: isSet(object.exp) ? globalThis.Number(object.exp) : 0,
            iat: isSet(object.iat) ? globalThis.Number(object.iat) : 0,
            iss: isSet(object.iss) ? globalThis.String(object.iss) : "",
            jti: isSet(object.jti) ? globalThis.String(object.jti) : "",
        };
    },

    toJSON(message: TokenPayload): unknown {
        const obj: any = {};
        if (message.email !== "") {
            obj.email = message.email;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.sub !== "") {
            obj.sub = message.sub;
        }
        if (message.aud !== "") {
            obj.aud = message.aud;
        }
        if (message.exp !== 0) {
            obj.exp = Math.round(message.exp);
        }
        if (message.iat !== 0) {
            obj.iat = Math.round(message.iat);
        }
        if (message.iss !== "") {
            obj.iss = message.iss;
        }
        if (message.jti !== "") {
            obj.jti = message.jti;
        }
        return obj;
    },

    create(base?: DeepPartial<TokenPayload>): TokenPayload {
        return TokenPayload.fromPartial(base ?? {});
    },
    fromPartial(object: DeepPartial<TokenPayload>): TokenPayload {
        const message = createBaseTokenPayload();
        message.email = object.email ?? "";
        message.name = object.name ?? "";
        message.sub = object.sub ?? "";
        message.aud = object.aud ?? "";
        message.exp = object.exp ?? 0;
        message.iat = object.iat ?? 0;
        message.iss = object.iss ?? "";
        message.jti = object.jti ?? "";
        return message;
    },
};

function createBaseGetPublicKeyRequest(): GetPublicKeyRequest {
    return {keyId: undefined};
}

export const GetPublicKeyRequest: MessageFns<GetPublicKeyRequest> = {
    encode(message: GetPublicKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.keyId !== undefined) {
            writer.uint32(10).string(message.keyId);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetPublicKeyRequest {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPublicKeyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.keyId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): GetPublicKeyRequest {
        return {
            keyId: isSet(object.keyId)
                ? globalThis.String(object.keyId)
                : isSet(object.key_id)
                    ? globalThis.String(object.key_id)
                    : undefined,
        };
    },

    toJSON(message: GetPublicKeyRequest): unknown {
        const obj: any = {};
        if (message.keyId !== undefined) {
            obj.keyId = message.keyId;
        }
        return obj;
    },

    create(base?: DeepPartial<GetPublicKeyRequest>): GetPublicKeyRequest {
        return GetPublicKeyRequest.fromPartial(base ?? {});
    },
    fromPartial(object: DeepPartial<GetPublicKeyRequest>): GetPublicKeyRequest {
        const message = createBaseGetPublicKeyRequest();
        message.keyId = object.keyId ?? undefined;
        return message;
    },
};

function createBaseGetPublicKeyResponse(): GetPublicKeyResponse {
    return {publicKey: "", keyId: ""};
}

export const GetPublicKeyResponse: MessageFns<GetPublicKeyResponse> = {
    encode(message: GetPublicKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.publicKey !== "") {
            writer.uint32(18).string(message.publicKey);
        }
        if (message.keyId !== "") {
            writer.uint32(26).string(message.keyId);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetPublicKeyResponse {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPublicKeyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.publicKey = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.keyId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): GetPublicKeyResponse {
        return {
            publicKey: isSet(object.publicKey)
                ? globalThis.String(object.publicKey)
                : isSet(object.public_key)
                    ? globalThis.String(object.public_key)
                    : "",
            keyId: isSet(object.keyId)
                ? globalThis.String(object.keyId)
                : isSet(object.key_id)
                    ? globalThis.String(object.key_id)
                    : "",
        };
    },

    toJSON(message: GetPublicKeyResponse): unknown {
        const obj: any = {};
        if (message.publicKey !== "") {
            obj.publicKey = message.publicKey;
        }
        if (message.keyId !== "") {
            obj.keyId = message.keyId;
        }
        return obj;
    },

    create(base?: DeepPartial<GetPublicKeyResponse>): GetPublicKeyResponse {
        return GetPublicKeyResponse.fromPartial(base ?? {});
    },
    fromPartial(object: DeepPartial<GetPublicKeyResponse>): GetPublicKeyResponse {
        const message = createBaseGetPublicKeyResponse();
        message.publicKey = object.publicKey ?? "";
        message.keyId = object.keyId ?? "";
        return message;
    },
};

/** Auth service for token verification and key management */
export type AuthServiceDefinition = typeof AuthServiceDefinition;
export const AuthServiceDefinition = {
    name: "AuthService",
    fullName: "auth.AuthService",
    methods: {
        /** Get the current public key */
        getPublicKey: {
            name: "GetPublicKey",
            requestType: GetPublicKeyRequest,
            requestStream: false,
            responseType: GetPublicKeyResponse,
            responseStream: false,
            options: {},
        },
    },
} as const;

export interface AuthServiceImplementation<CallContextExt = {}> {
    /** Get the current public key */
    getPublicKey(
        request: GetPublicKeyRequest,
        context: CallContext & CallContextExt,
    ): Promise<DeepPartial<GetPublicKeyResponse>>;
}

export interface AuthServiceClient<CallOptionsExt = {}> {
    /** Get the current public key */
    getPublicKey(
        request: DeepPartial<GetPublicKeyRequest>,
        options?: CallOptions & CallOptionsExt,
    ): Promise<GetPublicKeyResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
    : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
        : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
            : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
                : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;

    decode(input: BinaryReader | Uint8Array, length?: number): T;

    fromJSON(object: any): T;

    toJSON(message: T): unknown;

    create(base?: DeepPartial<T>): T;

    fromPartial(object: DeepPartial<T>): T;
}
